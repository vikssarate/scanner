<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<meta name="apple-mobile-web-app-capable" content="yes"/>
<title>Scan & Merge (Camera → Tap → Crop → JPG/PDF)</title>
<style>
:root{--bg:#0f1220;--card:#181c2f;--ink:#eef1ff;--muted:#9aa3c7;--line:#2a3052;--accent:#6ca8ff;--ok:#7bd88f;--bad:#ff7575}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu}
header,footer{display:flex;gap:8px;align-items:center;justify-content:space-between;padding:12px 16px;border-bottom:1px solid var(--line)}
h1{font-size:18px;margin:0}
.wrap{max-width:1100px;margin:0 auto;padding:12px}
.panel{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:12px}
.row{display:flex;gap:8px;flex-wrap:wrap}
.btn{appearance:none;border:1px solid var(--line);background:#12162a;color:var(--ink);
     padding:10px 14px;border-radius:10px;font-weight:600;cursor:pointer}
.btn:disabled{opacity:.5;cursor:not-allowed}
.primary{background:var(--accent);border-color:transparent;color:#07152a}
.ok{background:var(--ok);border-color:transparent;color:#06210f}
.bad{background:var(--bad);border-color:transparent;color:#2a0808}
.small{font-size:12px;color:var(--muted)}
hr{border:none;border-top:1px solid var(--line);margin:12px 0}
.notice{font-size:13px;color:var(--muted)}

#camWrap{position:relative}
video{width:100%;border-radius:12px;background:#000;display:block}
/* Tap-anywhere capture overlay — must be transparent on iPad Safari */
#tapToShoot{
  position:absolute; inset:0; border-radius:12px;
  background: transparent !important;   /* ← kill white fill */
  color: transparent;                    /* no text flash */
  border: 0;                             /* reset default iOS button border */
  outline: none;
  -webkit-appearance: none; appearance: none;  /* remove native UIButton look */
  padding: 0;
}
/* only show a subtle dashed frame when we want to hint “tap to capture” */
#tapToShoot.hint{ border:2px dashed rgba(255,255,255,.25); }
#stage{position:relative;display:none;margin-top:8px}
#stage.ready{display:block}
#stage img{display:block;width:100%;height:auto;user-select:none;-webkit-user-drag:none;border-radius:12px}
#cropBox{
  position:absolute;border:2px dashed rgba(255,255,255,.95);
  background:rgba(255,255,255,.05);
  box-shadow:0 0 0 100vmax rgba(0,0,0,.45);
  touch-action:none;
}
.handle{position:absolute;width:18px;height:18px;border-radius:50%;background:#fff;border:2px solid #000}
.handle.nw{left:-10px;top:-10px}
.handle.ne{right:-10px;top:-10px}
.handle.sw{left:-10px;bottom:-10px}
.handle.se{right:-10px;bottom:-10px}

.gallery{display:grid;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:8px;margin-top:10px}
.thumb{position:relative}
.thumb img{width:100%;border-radius:10px;border:1px solid var(--line);display:block;background:#000}
.thumb button{position:absolute;top:6px;right:6px}
.toolbar{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
</style>
</head>
<body>
<header class="wrap">
  <h1>Scan & Merge</h1>
  <div class="row">
    <button id="startBtn" class="btn primary">Start camera</button>
    <button id="tapToShoot" aria-label="Tap to capture"></button>
    <button id="switchBtn" class="btn" disabled>Switch camera</button>
    <button id="clearBtn" class="btn bad" disabled>Clear all</button>
  </div>
</header>

<div class="wrap">
  <div class="panel">

    <!-- Live camera -->
    <div id="camWrap">
      <video id="video" playsinline muted></video>
      <!-- Tap anywhere overlay to capture -->
      <button id="tapToShoot" aria-label="Tap to capture"></button>
    </div>

    <!-- Crop stage -->
    <div id="stage">
      <img id="capturedImg" alt="Captured"/>
      <div id="cropBox">
        <div class="handle nw" data-dir="nw"></div>
        <div class="handle ne" data-dir="ne"></div>
        <div class="handle sw" data-dir="sw"></div>
        <div class="handle se" data-dir="se"></div>
      </div>
      <div class="toolbar">
        <button id="useCropBtn" class="btn ok">Use crop (Add page)</button>
        <button id="retakeBtn" class="btn">Retake</button>
      </div>
      <div class="notice">Tip: drag the box to move; drag white circles to resize.</div>
    </div>

    <div class="toolbar">
      <button id="exportJPG" class="btn" disabled>Export as one JPG</button>
      <button id="exportPDF" class="btn" disabled>Export as PDF</button>
    </div>

    <hr/>
    <div class="small">Pages (tap × to remove):</div>
    <div id="gallery" class="gallery"></div>
  </div>

  <p class="notice">Use over HTTPS. Tap anywhere on the camera preview to capture.</p>
</div>

<footer class="wrap"><span class="small">© You</span></footer>

<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
<script>
(() => {
  const video = document.getElementById('video');
  const tapToShoot = document.getElementById('tapToShoot');
  const startBtn = document.getElementById('startBtn');
  const captureBtn = document.getElementById('captureBtn');
  const switchBtn = document.getElementById('switchBtn');
  const clearBtn = document.getElementById('clearBtn');
  const exportJPG = document.getElementById('exportJPG');
  const exportPDF = document.getElementById('exportPDF');

  const stage = document.getElementById('stage');
  const imgEl = document.getElementById('capturedImg');
  const cropBox = document.getElementById('cropBox');
  const useCropBtn = document.getElementById('useCropBtn');
  const retakeBtn = document.getElementById('retakeBtn');
  const gallery = document.getElementById('gallery');

  let stream = null;
  let usingRear = true;

  // Each page = { blob, url, w, h }
  let pages = [];

  function uiCamera(on) {
    captureBtn.disabled = !on;
    switchBtn.disabled = !on;
    tapToShoot.classList.toggle('hint', on);
  }
  function uiExports() {
    const on = pages.length > 0;
    exportJPG.disabled = !on;
    exportPDF.disabled = !on;
    clearBtn.disabled = !on;
  }

  async function startCamera(rear = true) {
    stopCamera();
    usingRear = rear;
    try {
      stream = await navigator.mediaDevices.getUserMedia({
        audio:false,
        video:{
          facingMode: rear ? {ideal:'environment'} : 'user',
          width:{ideal:1920}
        }
      });
      video.srcObject = stream;
      await video.play();
      uiCamera(true);
    } catch(e) {
      alert('Camera error: '+e.message+'\n(Use HTTPS and allow camera)');
      uiCamera(false);
    }
  }
  function stopCamera(){
    if (stream) stream.getTracks().forEach(t=>t.stop());
    stream = null;
    uiCamera(false);
  }

  // Capture helpers
  function drawFrameToCanvas() {
    const vw = video.videoWidth || 1920, vh = video.videoHeight || 1080;
    const c = document.createElement('canvas');
    c.width = vw; c.height = vh;
    c.getContext('2d').drawImage(video, 0, 0, vw, vh);
    return c;
  }
  function canvasToBlob(canvas, type='image/jpeg', quality=0.95){
    return new Promise(res => {
      if (canvas.toBlob) canvas.toBlob(b => res(b), type, quality);
      else {
        const dataURL = canvas.toDataURL(type, quality);
        const b = dataURLToBlob(dataURL);
        res(b);
      }
    });
  }
  function dataURLToBlob(dataURL){
    const [hdr, data] = dataURL.split(',');
    const mime = hdr.match(/:(.*?);/)[1];
    const bin = atob(data);
    const arr = new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) arr[i] = bin.charCodeAt(i);
    return new Blob([arr], {type:mime});
  }
  function blobToDataURL(blob){
    return new Promise(r => { const fr = new FileReader(); fr.onload = () => r(fr.result); fr.readAsDataURL(blob); });
  }

  // --- Crop state (in CSS px relative to displayed image) ---
  let dragging = null; // 'move' or 'nw' | 'ne' | 'sw' | 'se'
  let rect = {x:0,y:0,w:100,h:100};
  let start = null;
  let stageBox = null;

  function measureStage() {
    // Wait one frame to ensure layout is final on iPad Safari
    return new Promise(res => requestAnimationFrame(() => {
      stageBox = imgEl.getBoundingClientRect();
      res();
    }));
  }
  function clamp(r){
    r.w = Math.max(24, Math.min(r.w, stageBox.width));
    r.h = Math.max(24, Math.min(r.h, stageBox.height));
    r.x = Math.max(0, Math.min(r.x, stageBox.width - r.w));
    r.y = Math.max(0, Math.min(r.y, stageBox.height - r.h));
  }
  function paintCrop(){
    cropBox.style.left = rect.x+'px';
    cropBox.style.top  = rect.y+'px';
    cropBox.style.width= rect.w+'px';
    cropBox.style.height=rect.h+'px';
  }
  function showCropFromBlob(blob){
    const url = URL.createObjectURL(blob);
    imgEl.onload = async () => {
      stage.style.display = 'block';
      await measureStage();
      // 80% centered box
      rect.w = Math.round(stageBox.width*0.8);
      rect.h = Math.round(stageBox.height*0.8);
      rect.x = Math.round((stageBox.width-rect.w)/2);
      rect.y = Math.round((stageBox.height-rect.h)/2);
      paintCrop();
      stage.classList.add('ready');
      video.style.display = 'none';
      tapToShoot.style.display = 'none';
    };
    imgEl.src = url;
    // Revoke later (after load) — safe for iOS
    imgEl.addEventListener('load', () => URL.revokeObjectURL(url), {once:true});
  }
  function hideCrop(){
    stage.classList.remove('ready');
    stage.style.display = 'none';
    video.style.display = 'block';
    tapToShoot.style.display = 'block';
  }
  function cssRectToImageRect(){
    const sx = Math.round(rect.x * (imgEl.naturalWidth / stageBox.width));
    const sy = Math.round(rect.y * (imgEl.naturalHeight / stageBox.height));
    const sw = Math.round(rect.w * (imgEl.naturalWidth / stageBox.width));
    const sh = Math.round(rect.h * (imgEl.naturalHeight / stageBox.height));
    return {sx,sy,sw,sh};
  }

  // Move/resize crop (pointer events work well on iPad)
  cropBox.addEventListener('pointerdown', (e)=>{
    const dir = e.target.dataset.dir;
    dragging = dir || 'move';
    start = {x:e.clientX, y:e.clientY, rect:{...rect}};
    cropBox.setPointerCapture(e.pointerId);
  }, {passive:false});
  cropBox.addEventListener('pointermove', (e)=>{
    if (!dragging) return;
    const dx = e.clientX - start.x;
    const dy = e.clientY - start.y;
    let r = {...start.rect};
    if (dragging === 'move'){ r.x += dx; r.y += dy; }
    else {
      if (dragging.includes('w')) { r.x += dx; r.w -= dx; }
      if (dragging.includes('e')) { r.w += dx; }
      if (dragging.includes('n')) { r.y += dy; r.h -= dy; }
      if (dragging.includes('s')) { r.h += dy; }
    }
    clamp(r); rect = r; paintCrop();
  }, {passive:false});
  cropBox.addEventListener('pointerup', ()=> dragging=null);
  cropBox.addEventListener('lostpointercapture', ()=> dragging=null);

  // --- Gallery ---
  function renderGallery(){
    gallery.innerHTML = '';
    pages.forEach((p,i)=>{
      const d = document.createElement('div'); d.className='thumb';
      const im = document.createElement('img'); im.src = p.url; im.alt = `Page ${i+1}`;
      const del = document.createElement('button'); del.className='btn bad small'; del.textContent='×';
      del.onclick = () => { URL.revokeObjectURL(p.url); pages.splice(i,1); renderGallery(); uiExports(); };
      const label = document.createElement('div'); label.className='small'; label.style.padding='6px'; label.textContent=`Page ${i+1}`;
      d.append(im, del, label);
      gallery.appendChild(d);
    });
  }

  // --- Buttons ---
  startBtn.onclick   = () => startCamera(true);
  switchBtn.onclick  = () => startCamera(!usingRear);
  captureBtn.onclick = onTapCapture;
  tapToShoot.onclick = onTapCapture;

  async function onTapCapture(){
    if (!stream || stage.classList.contains('ready')) return;
    const canvas = drawFrameToCanvas();
    const blob = await canvasToBlob(canvas, 'image/jpeg', 0.92);
    showCropFromBlob(blob);
  }

  retakeBtn.onclick = () => hideCrop();

  useCropBtn.onclick = async () => {
    // Crop the displayed image using natural pixels
    const {sx, sy, sw, sh} = cssRectToImageRect();
    // Draw from the temporary displayed image
    const c = document.createElement('canvas'); c.width = sw; c.height = sh;
    const ctx = c.getContext('2d');
    // Ensure the source image is ready
    ctx.drawImage(imgEl, sx, sy, sw, sh, 0, 0, sw, sh);
    const blob = await canvasToBlob(c, 'image/jpeg', 0.95);
    const url  = URL.createObjectURL(blob);
    pages.push({blob, url, w: sw, h: sh});
    renderGallery(); uiExports();
    hideCrop();
  };

  clearBtn.onclick = () => {
    if (!pages.length) return;
    if (confirm('Remove all pages?')) {
      pages.forEach(p => URL.revokeObjectURL(p.url));
      pages = []; renderGallery(); uiExports();
    }
  };

  // --- Exporters ---
  exportJPG.onclick = async () => {
    if (!pages.length) return;
    // Use max width; scale others to match; stitch vertically
    const imgs = await loadAllImages(pages);
    const targetW = Math.max(...imgs.map(im => im.width));
    const pad = 8;
    const totalH = imgs.reduce((s,im)=> s + Math.round(im.height * (targetW/im.width)), 0) + pad*(imgs.length-1);
    const c = document.createElement('canvas'); c.width = targetW; c.height = totalH;
    const ctx = c.getContext('2d');
    let y = 0;
    for (const im of imgs){
      const h = Math.round(im.height * (targetW/im.width));
      ctx.drawImage(im, 0, y, targetW, h);
      y += h + pad;
    }
    c.toBlob(b => downloadBlob(b, 'scan-merged.jpg'), 'image/jpeg', 0.95);
  };

  exportPDF.onclick = async () => {
    if (!pages.length) return;
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({unit:'mm', format:'a4'});
    for (let i=0;i<pages.length;i++){
      if (i>0) doc.addPage();
      const dataURL = await blobToDataURL(pages[i].blob);
      await addImageFitA4(doc, dataURL);
    }
    doc.save('scan.pdf');
  };

  function loadAllImages(items){
    // Prefer createImageBitmap for speed on iPad; fallback to <img>
    if ('createImageBitmap' in window){
      return Promise.all(items.map(p => createImageBitmap(p.blob)));
    }
    return Promise.all(items.map(p => new Promise(res=>{
      const im = new Image(); im.onload = () => res(im);
      im.src = p.url;
    })));
  }
  async function addImageFitA4(doc, dataUrl){
    const im = await new Promise(r => { const i=new Image(); i.onload=()=>r(i); i.src=dataUrl; });
    const pageW = doc.internal.pageSize.getWidth(), pageH = doc.internal.pageSize.getHeight();
    let w = pageW, h = (im.height*w)/im.width;
    if (h>pageH){ h = pageH; w = (im.width*h)/im.height; }
    const x = (pageW-w)/2, y=(pageH-h)/2;
    doc.addImage(dataUrl, 'JPEG', x, y, w, h);
  }
  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = filename;
    document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url), 1000);
  }

  // Clean up camera if tab hidden
  document.addEventListener('visibilitychange', () => { if (document.hidden) stopCamera(); });

  // Init
  uiCamera(false); uiExports();
})();
</script>
</body>
</html>
